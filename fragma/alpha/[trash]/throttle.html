<!DOCTYPE html>

<head>
  <meta charset=utf-8>
  <meta name=viewport content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>SMotaal's Component Throttle Experiment</title>
  <link rel=prefetch href="components/component-a.js">
  <link rel=stylesheet src="styles/base.css">
  <script src="scripts/globals.js"></script>
  <base href="./">
  <!-- <script src="/prototypes/prototypes.js"></script> -->
  <!-- <script src="/caches.js"></script> -->
</head>

<body>

  <slot name=component-a>
    <template id=components>
      <component-a><button slot="button">component-a</button></component-a>
    </template>
  </slot>


  <script type=module>
    import ComponentA from './components/component-a.js';

    const replicates = (self.replicates >= 0 && self.replicates) || 10;

    self.onhashchange || (self.onhashchange = ({newURL}) => /#\d/.test(newURL) && location.reload());

    replicate('component-a', ComponentA, select('template#components'), replicates);

    async function replicate(tagName, Component, template, replicates) {
      const title = document.title;
      const label = `Initializing ${tagName} × ${replicates}`;

      console.group(label), console.time(label);

      let initialized, parent, element;
      const promises = new Set();
      const errors = [];
      const promise = promise => (promises.add(promise), promise);
      const error = error => (error.push(error), error);

      try {
        element = select(tagName, (template && template.content) || document);

        // await idled;
        // await rendered;

        if (element && replicates) {
          promise(
            timelined(`Replicating ${tagName} × ${replicates}`, async () => {
              const fragments = (async function* replicate(element) {
                let fragment = document.createDocumentFragment();
                for (let n = replicates; --n;) {
                  fragment.appendChild(element.cloneNode(true));
                  if (!(n % 250)) {
                    yield fragment;
                    fragment = document.createDocumentFragment();
                  }
                }
                if (fragment.childElementCount) yield fragment;
              })(element);

              let last = element;
              for await (const fragment of fragments) {
                const next = fragment.lastElementChild;
                await rendered;
                last.after(fragment);
                last = next;
                await timeout(100);
              }

              last = null;
          }));

          // promise(
          //   timelined(`Replicating ${tagName} × ${replicates}`, async () => {
          //     const fragments = [];
          //     let fragment = document.createDocumentFragment();

          //     for (let n = replicates; --n;) {
          //       fragment.appendChild(element.cloneNode(true));
          //       n % 1000 || (
          //         fragments.push(fragment),
          //         fragment = document.createDocumentFragment()
          //       );
          //     }

          //     fragment.childElementCount && fragments.push(fragment);
          //     fragment = null;

          //     let last = element;
          //     for (const fragment of fragments) {
          //       const next = fragment.lastElementChild;
          //       last.after(fragment);
          //       last = next;
          //       // await timeout(0);
          //       await rendered;
          //     }
          //     last = null;

          //   }),
          // );
        }

        await rendered;

        await promise(
          timelined(
            `Defining ${tagName}`,
            () => (Component.define(), customElements.whenDefined(tagName)),
          ),
        );

        await rendered;

        template &&
          promise(
            timelined(`Rendering ${tagName} × ${replicates}`, () => template.before(template.content)),
          );

        const elements = selectAll(tagName);

        let n = 0;
        for (const element of selectAll(tagName)) {
          n++ % 500 || (await rendered);
          promise(element.initialized);
        }
      } finally {
        initialized = await Promise.all(promises).catch(error);
        errors.length && console.warn(...errors);
        console.timeEnd(label), console.groupEnd();
      }

      // template && template.remove();
      element && element.parentElement && (document.title = `√ ${element.parentElement.querySelectorAll(tagName).length} × ${tagName}`);

      // setTimeout(() => document.title = title, 5000);
      return true;
    }

  </script>

</body>

</html>
