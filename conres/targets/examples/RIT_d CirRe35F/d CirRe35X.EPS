%!PS-Adobe-3.0 EPSF-3.0 
%%BoundingBox: 0 0 612 792 
%%Title: (Contrast-Resolution Target v3.5) 
%%Creator: (Franz Sigg) 
%%CreationDate: (Apr. 19, 00, modified Mar 29, 2019) 
%%Copyright: (Copyright (c) 2000 - 2019, Franz Sigg, CH8405 Winterthur, Switzerland, for design and programming of EPS code) 
%%+ (All Rights Reserved.) 
%%For: Not Validated 
%%DocumentNeededResources: font Helvetica 
%%DocumentFonts: Helvetica 
%%EndComments 
 
%%BeginProlog 
%%EndProlog 
%%BeginSetup 
%%EndSetup 
save mark 
330 dict begin  % Temporary MyDict for EPS 
/mm { 2.834646 mul } bind def 
/in { 72 mul       } bind def 
 
% The BoundingBox size is the paper size in PostScript units that will be used to print the target. 
% The first two numbers of the BoundingBox statement are always zero. 
% The 3rd and 4th numbers are rounded down PS units of paper size. BBox should not be larger than nominal paper size, 
%   otherwise, the printer may tile or shrink to fit. 
% The image will leave a margin of at least 8 mm or 5/16 in. 
 
%  1 inch = 72 PSunits. 1 mm = 2.83464 PSunits, 1 PS unit = 0.35278 mm. 
%  Letter size  = 8.5 x 11 in = 612  792 PS 
%  Legal  size  = 8.5 x 14 in = 612 1008 PS 
%  Tabloid size =  11 x 17 in = 792 1224 PS 
%  Tabloid plus =  12 x 18 in = 864 1296 PS 
 
%  A4          = 210 x 297 mm = 595  841 PS 
%  A3          = 297 x 420 mm = 841 1190 PS 
 
% The ConRes blocks will be automatically distributed to fit on the page size leaving a margin of at least 8 mm or 5/16 in. 
% When making the PDF from this EPS file using Distiller, there will be as many pages as necessary to 
%   fill the requirements that are defined by the variables below. 
 
/BBX     612     def   % Copy the third  number of the %%BoundingBox statement above 
/BBY     792     def   % Copy the fourth number of the %%BoundingBox statement above 
 
 
 
% LINEARIZATION ToneValues 
% Since resolution is a function of contrast, when printing the target, possible tone value increase (dot gain) will 
% have an effect on the ConRes response. Therefore it makes sense to first normalize the tone reproduction curve of 
% the printing device. Normalizing means that uniform tone values steps will result in uniforms either density or L* steps 
% on the print. This is done by first making a print on the calibrated device, using nominal tone values, measure 
% the steps on the printed wedges, entering the measurements in the arrays below and then making a second, normalized print. 
% The normalized print should then have uniform step increments using the measurement units that were used to measure the 
% first print (either Density or L*) 
% Use the following procedure: 
 
% 1. Set the NominalTVflag to 0. This prints the nominal values on the wedges. 
 
% 2. Print this test target on the (calibrated) output device. 
 
% 3. Read and record the printed wedges of all pages, at least one, not more than a total of 8 wedges. 
 
% 4. Replace the measurements of each step in the 'MeasuredPrintArrayX' arrays below with the readings you have 
%    taken. At least the readings of one wedge are needed, but the measuremenets of up to 8 wedges can be entered. 
%    Empty arrays will be ignored. The program will average these readings. 
%    Use an i1 Spectrophotometer. You can enter either L* values or Density values. Linearization will be according to 
%    the entered values. 
 
% 5. Change the NominalTVflag to 1. 
 
% 6. Copy the identification code printed on the first target into the IDcode variable below. 
 
% 7. Print the target again. Now the steps of the gray scale are linearized and should be distinct from one another. 
%    Now the ConRes performance of this normalized target can be analyzed. 
 
 
/NominalTVflag 1 def    % If the NominalTVflag is set to 0, then the measured values are ignored and the target 
                        % is printed with nominal tone values. If set to 1 then a Linearized target is printed. 
 
/IDcode (Not Entered) def   % Copy the value printed on the first print to the IDcode before making the second print. 
% Tone values must start with zero and end with 100. 
 
	/NominalTVArray 		[  0    5   10   15   20   25   30   35   40   45   50   55   60    65    70    75    80    85    90  95  100 ] def 
 
	/MeasuredPrintArray1	[  ] def 
%	/MeasuredPrintArray2	[ .0  .05  .11  .17  .22  .28  .35  .44  .55  .68  .80  .91  1.02  1.13  1.23  1.30  1.36  1.42  1.48  1.60 ] def 
	/MeasuredPrintArray2	[ .1  .14  .19  .24  .28  .33  .39  .47  .57  .69  .80  .91  1.02  1.13  1.23  1.30  1.36  1.42  1.48 1.53 1.60 ] def 
	/MeasuredPrintArray3	[  ] def 
	/MeasuredPrintArray4	[  ] def 
	/MeasuredPrintArray5	[  ] def 
	/MeasuredPrintArray6	[  ] def 
	/MeasuredPrintArray7	[  ] def 
	/MeasuredPrintArray8	[  ] def 
 
 
 
% The following parameters can be set to change the target. The values that are set in the original version of the 
% target are optimized for the automated analysis program, using a Tabloid (11x17 inch) or A3 paper size, on two pages. 
% This uses only the recommended black printer and tone vales from 5% to 95% in 5% steps. 
 
 
 /PX     10 def         %   Set the number of contrast steps. Must be between 6 and 26. 
 /PY     10 def         %   Set the number of spatial resolution steps. Must be between 9 and 26. 
 /ptch   8 mm def       %   Set the size of one patch with circles 
 
 
% RESOLUTION Range 
/startu     80 def      %   Enter starting line width in microns. (Frequency will be displayed in Line pairs / mm) 
/endu      800 def      %   Enter ending line width in microns. 
						%   The intermediate steps will automatically be generated with log 
						%   increments. endu should be larger than startu. A range of 10x is 
						%   suggested. 
						%   This is a test target that is based on visual perception. 
						%   The range from 80 to 800 covers the range that is visually 
						%   significant at reading distance. For visual significance it 
						%   does not make sense to go to higher resolutions. 
						%   Line pairs/mm = 1mm / (LineWidthMicrons / 1000 * 2) 
 
 
% CONTRAST Range: 
/startc   100	def		%   Enter starting contrast as percent. Cannot be more than 100%. 
						%   If BlockRefToneValue is not 50% then starting contrast will 
						%   automatically be set to twice the distance from either 
						%   zero or 100% contast, whichever is less. 
/endc		1	def 	%   Enter  ending  contrast as percent. A value of less than 
						%   1 percent may not be perceptible by the eye. (1% is about a 
						%   just noticeable difference.) 
						%   The visually significant range is from 100% to 1%. 
 
/FullCsteps 1 def		%   0= All contrast step increments are the same for all tone values 
						%   1- Contrast step increments are chosen to always fill all contrast steps for all Ref Tone Values 
 
 
% TONE VALUE Steps 
%/BlockRefToneValues  [ 5 10 15 20 25 30 35 40 45 50 55 60 65 70 80 85 90 95 ]  def 
/BlockRefToneValues  [ 10 20 30 40 50 60 70 80 90 ]  def 
%/BlockRefToneValues  [ 10 20 35 50 65 80 90 ]  def 
%/BlockRefToneValues  [ 50 70 ]  def 
                        %   Spatial resolution also depends on the tone value at which it is tested. 
                        %   Set matrix of reference tone values as percent tone value. 
                        %   Set from 1 to max. 9 values. Suggested values: [ 10 30 50 70 90 ] 
						%   Contrast range will be symmetrically centered around these 
						%   points, and as many as possible contrasts will be shown until 
						%   they are limited by either the 0% or 100% value. 
						%   For each tone value, one block of patches is generated. 
 
 
/NoOfBlocksInXdir 2 def	%   Define the number of blocks placed in X direction of page. This helps 
						%   to define the layout of the page. 
 
 
% ADDITIONAL OPTIONAL TARGETS 
/AddressabilityIndicatorFlag 1 def     % Set to zero or one. If set to 1, these 
/ScreenPatternIndicatorFlag  1 def     % two related targets will also be imaged. 
 
 
% COLOR 
/SetCol (K) def 		%   Define color of target. Choose from (C), (M), (Y), (K), 
                        %   This target uses Separation Color. It makes sense 
                        %   to only test black since probably the same technology is used for 
                        %   all colors, and black is most visible. 
 
/DotGrid	1 	def		%   Fiducial Alignment Grid with dots  1 = on   0 = off 
 
 
% MARGIN Width 
/pratio		1.15	def		% Gray band width between columns. Should be between 1 and 1.5 
 
 
%  Note: The above settings are documented in the .log file which is created when 
%        this EPS file is run through Adobe Distiller when making a PDF file. 
 
 
 
/SpotCorrection 0 def /SetDPI 0 def /SetBackground 1 def /Frame 1 def /un (Franz Sigg, Eric Zeise, Saleh Abdel Motaal ) def /lizdat (Mar-29-19) def  
/LicensedLocation () def /PDFcode ( ) def statusdict /product known { /snphh statusdict /product get def } { /snphh (Unknown output device) def }  
ifelse /uatvs /languagelevel where { pop languagelevel } { 1 } ifelse def /bkwuj /serialnumber where { pop serialnumber } { ( ) } ifelse def bkwuj 0 eq { /bkwuj  
( ) def } { /bkwuj bkwuj 50 string cvs def } ifelse /bkwuj bkwuj length 10 gt { bkwuj bkwuj length 10 sub 10 getinterval } { bkwuj } ifelse def /zwbyj { bind  
def } bind def /ntbpm { load def } zwbyj /hqqgh { version 20 string cvs } zwbyj /vvpzx /vmstatus ntbpm 72 72 matrix defaultmatrix dtransform /fszgn exch abs cvi  
def /czrao exch abs cvi def czrao cvi fszgn cvi lt { /ccuhb czrao def /hjhyz 0 def /kheeq 2 def } { /ccuhb fszgn def /hjhyz 1 def /kheeq 3 def } ifelse /kksiq  
72 ccuhb matrix currentmatrix hjhyz get abs dup mul matrix currentmatrix kheeq get abs dup mul add sqrt div div def /fepcl 0 def snphh length 8 gt { 0 1 snphh  
length 9 sub { snphh exch 9 getinterval (Distiller) eq { /fepcl 1 def } if } for } if SetDPI 0 ne { /ccuhb SetDPI def } if SetDPI 0 eq { fepcl 1 eq { /xgujh  
( Set by Distiller) def } { /xgujh ( Set by RIP) def } ifelse } { /xgujh ( Set in EPS file) def } ifelse /xqqlc ccuhb 15 string cvs def /osxva 72 ccuhb div  
kksiq div def 1 1 /oxlrn { osxva mul } zwbyj /nmjkh { osxva div round cvi osxva mul } zwbyj /ll exch def /in { 72 mul } zwbyj /bgzbk { 100000 ccuhb 2.54 div div  
round cvi 10 div } bind def /jmemg <4672616E7A20536967672C2045726963205A656973652C2053616C656820416264656C204D6F7461616C20> def /II exch def /qoeyr /stringwidth ntbpm  
/nkcul { qoeyr pop } zwbyj /tpvaf { qoeyr pop add } zwbyj /bcida { 50 string cvs } zwbyj /nrovc { 50 string cvs qoeyr pop add } zwbyj /erljd { 50 string cvs  
qoeyr pop } zwbyj /synct { 100 string cvs qoeyr pop add } zwbyj /kmmfi /setlinewidth ntbpm /cpeyc { un 0 exch { add } forall jmemg 0 exch { add } forall } zwbyj  
/lhwth <4D61722D32392D3139> def /rgcai { dup qoeyr pop 2 div 4 -1 roll exch sub 3 -1 roll yqjdm ovoln } zwbyj /uhgmg { dup qoeyr pop 4 -1 roll exch sub 3 -1  
roll yqjdm ovoln } zwbyj /ibmfw { lizdat 0 exch { add } forall lhwth 0 exch { add } forall } zwbyj /ptyio { 15 string cvs rgcai } zwbyj /cqkyc { dup sin exch  
cos div } zwbyj /llllll 1 def /yqjdm /moveto ntbpm /fzdai /lineto ntbpm /oxnkw /repeat ntbpm /vrszi /rlineto ntbpm /mksek /rmoveto ntbpm /ovoln /show ntbpm  
/fqmrx 72 1.4142135 oxlrn div kksiq div round cvi 10 div def /show { 0 0 yqjdm .1 .1 vrszi -.1 0 vrszi hjlyd clip fjkhn } zwbyj cpeyc ne ibmfw ne or { /ll 0 def  
} if /jhhdn { 50 string cvs ovoln } zwbyj /fpjwm { 50 string cvs uhgmg } zwbyj /ertpu { 50 string cvs } zwbyj /evfyb { 50 string cvs print } zwbyj /erljd { 50  
string cvs qoeyr pop } zwbyj /bujmd <> def /debsn { LicensedLocation 0 exch { add } forall bujmd 0 exch { add } forall } zwbyj debsn ne {  
/ll 0 def } if /ofmtt /gsave ntbpm /kxtcq /grestore ntbpm /salkh { jmemg 0 exch { add } forall 3689 } zwbyj /zuskt { bujmd 0 exch { add } forall 0 } zwbyj  
/hjlyd /closepath ntbpm /qjcec { lhwth 0 exch { add } forall 591 } zwbyj /lyomz (541FS290319) def /fjkhn /newpath ntbpm salkh ne qjcec ne or zuskt ne or { /II 0  
def } if /dnzox { transform .25 sub round cvi .25 add exch .25 sub round cvi .25 add exch itransform yqjdm } zwbyj /rlsbt { transform .25 sub round cvi .25 add  
exch .25 sub round cvi .25 add exch itransform mksek } zwbyj /smefi { transform .50 sub round cvi .50 add exch .50 sub round cvi .50 add exch itransform yqjdm  
} zwbyj /ubntu { transform .25 sub round cvi .25 add exch .25 sub round cvi .25 add exch itransform vrszi } zwbyj /izurx { translate 0 0 yqjdm 90 rotate }  
zwbyj ll II mul 0 eq { 0 0 yqjdm .1 .1 vrszi -.1 0 vrszi hjlyd clip fjkhn } if /wkdyu <353431465332393033> def /skaee { makefont setfont } zwbyj /nkchq { () =  
pstack () = } zwbyj /wmexj where { pop false wmexj } if /iuflg { /wpjkw exch def wpjkw (K) eq { [ /Separation (Black) /DeviceCMYK { 0 0 0 4 -1 roll } ]  
setcolorspace uwcok setcolor } if wpjkw (C) eq { [ /Separation (Cyan) /DeviceCMYK { 0 0 0 } ] setcolorspace uwcok setcolor } if wpjkw (M) eq { [ /Separation  
(Magenta) /DeviceCMYK { 0 exch 0 0 } ] setcolorspace uwcok setcolor } if wpjkw (Y) eq { [ /Separation (Yellow) /DeviceCMYK { 0 0 3 -1 roll 0 } ] setcolorspace  
uwcok setcolor } if } def /pyniw NominalTVArray length def /ggeja pyniw array def 0 1 pyniw 1 sub { ggeja exch 0 put } for /tvhsk 0 def MeasuredPrintArray1  
length 0 ne { /tvhsk tvhsk 1 add def } if MeasuredPrintArray2 length 0 ne { /tvhsk tvhsk 1 add def } if MeasuredPrintArray3 length 0 ne { /tvhsk tvhsk 1 add def  
} if MeasuredPrintArray4 length 0 ne { /tvhsk tvhsk 1 add def } if MeasuredPrintArray5 length 0 ne { /tvhsk tvhsk 1 add def } if MeasuredPrintArray6 length 0  
ne { /tvhsk tvhsk 1 add def } if MeasuredPrintArray7 length 0 ne { /tvhsk tvhsk 1 add def } if MeasuredPrintArray8 length 0 ne { /tvhsk tvhsk 1 add def } if 0 1  
pyniw 1 sub { /vtlck exch def MeasuredPrintArray1 length 0 ne { ggeja vtlck ggeja vtlck get MeasuredPrintArray1 vtlck get MeasuredPrintArray1 0 get sub add put  
} if MeasuredPrintArray2 length 0 ne { ggeja vtlck ggeja vtlck get MeasuredPrintArray2 vtlck get MeasuredPrintArray2 0 get sub add put } if MeasuredPrintArray3  
length 0 ne { ggeja vtlck ggeja vtlck get MeasuredPrintArray3 vtlck get MeasuredPrintArray3 0 get sub add put } if MeasuredPrintArray4 length 0 ne { ggeja vtlck  
ggeja vtlck get MeasuredPrintArray4 vtlck get MeasuredPrintArray4 0 get sub add put } if MeasuredPrintArray5 length 0 ne { ggeja vtlck ggeja vtlck get  
MeasuredPrintArray5 vtlck get MeasuredPrintArray5 0 get sub add put } if MeasuredPrintArray6 length 0 ne { ggeja vtlck ggeja vtlck get MeasuredPrintArray6 vtlck  
get MeasuredPrintArray6 0 get sub add put } if MeasuredPrintArray7 length 0 ne { ggeja vtlck ggeja vtlck get MeasuredPrintArray7 vtlck get MeasuredPrintArray7 0  
get sub add put } if MeasuredPrintArray8 length 0 ne { ggeja vtlck ggeja vtlck get MeasuredPrintArray8 vtlck get MeasuredPrintArray8 0 get sub add put } if }  
for 0 1 pyniw 1 sub { /vtlck exch def ggeja vtlck ggeja vtlck get tvhsk div put } for 1 1 pyniw 1 sub { /vtlck exch def ggeja vtlck get ggeja vtlck 1 sub get  
sub 0 lt { ggeja vtlck ggeja vtlck get ggeja vtlck 1 add get ggeja vtlck get sub 2 div add put } if } for 1 1 pyniw 1 sub { /vtlck exch def ggeja vtlck get  
ggeja vtlck 1 sub get sub 0 lt { ggeja vtlck ggeja vtlck get ggeja vtlck 1 add get ggeja vtlck get sub 2 div add put } if } for /isiud ggeja pyniw 1 sub get def  
/pygyc 0 def 1 1 pyniw 1 sub { /vtlck exch def /pygyc pygyc ggeja vtlck get add def } for /pygyc pygyc pyniw div def pygyc 6 gt { /pygyc (L*) def } { /pygyc  
(Den.) def } ifelse /zqpxo pyniw array def 0 1 pyniw 1 sub { /vtlck exch def zqpxo vtlck NominalTVArray vtlck get isiud mul NominalTVArray pyniw 1 sub get div  
put } for /gwblt { NominalTVflag 0 ne { /gjknh exch def /pfcxc exch def /qxgyw exch def /lmuvj exch def /fikdq exch def gjknh fikdq sub pfcxc lmuvj sub mul  
qxgyw fikdq sub div lmuvj add } if } zwbyj /cfsne { /zmalh exch def /txvec zmalh def zmalh 1 le { /txvec txvec 100 mul def } if /adjez txvec isiud mul  
NominalTVArray pyniw 1 sub get div def 0 1 pyniw 2 sub { /wpsdg exch def adjez ggeja wpsdg get ge adjez ggeja wpsdg 1 add get le and { exit for } if } for  
NominalTVflag 0 ne { ggeja wpsdg get NominalTVArray wpsdg get ggeja wpsdg 1 add get NominalTVArray wpsdg 1 add get adjez gwblt /avuui exch 1000 mul round cvi  
1000 div def zmalh 1 le { /avuui avuui 100 div def } if } { /avuui zmalh def } ifelse avuui } zwbyj /louof pyniw array def 0 1 pyniw 1 sub { /fjoin exch def  
louof fjoin NominalTVArray fjoin get cfsne put } for /lobof { ofmtt /zyzvk 1 def .8 bdill ayfxl ojdtf mul add ojdtf .5 mul add bxmrb ematv mul ematv .5 mul add  
translate ojdtf 192 div ematv 192 div lt { ojdtf 192 div } { ematv 192 div } ifelse dup scale 72 72 matrix defaultmatrix dtransform /fszgn exch abs cvi def  
/czrao exch abs cvi def czrao cvi fszgn cvi lt { /ccuhb czrao def /hjhyz 0 def /kheeq 2 def } { /ccuhb fszgn def /hjhyz 1 def /kheeq 3 def } ifelse /uzges 72  
ccuhb matrix currentmatrix hjhyz get abs dup mul matrix currentmatrix kheeq get abs dup mul add sqrt div div def SetDPI 0 ne { /ccuhb SetDPI def } if /xqqlc  
ccuhb 15 string cvs def /osxva 72 ccuhb div uzges div def /oxlrn { osxva mul } zwbyj /nmjkh { osxva div round cvi osxva mul } zwbyj /aiscc 192 def /hkoih 280  
def /vijkv { aiscc mul } zwbyj /ksrky { .78 vijkv } zwbyj fszgn czrao ne { /ksrky ksrky 0.97 mul def } if /qnfpt 1 in hkoih div uzges div def /lxhrx 111 hkoih  
mul 245 div 2 mul 1 add uzges mul cvi 2 div cvi 1 add def /hjahz lxhrx 1 sub 2 div round def /tppgn hjahz qnfpt mul def /uwcok 1 def (K) iuflg aiscc 2 div neg  
dup translate 0 0 yqjdm ofmtt .25 nmjkh 2 mul setlinewidth .25 nmjkh dup translate 0 0 moveto 0 aiscc cvi .25 nmjkh 2 mul sub rlineto aiscc cvi .25 nmjkh 2 mul  
sub 0 rlineto 0 aiscc cvi .25 nmjkh 2 mul sub neg rlineto hjlyd ofmtt /uwcok 0 def (K) iuflg fill kxtcq stroke kxtcq .17 vijkv .17 vijkv .02 vijkv add translate  
0 0 transform 0.5 sub round 0.5 add exch 0.5 sub round 0.5 add exch itransform yqjdm currentpoint translate fjkhn 0 kmmfi ofmtt /uwcok 1 def SetCol iuflg hjahz  
neg 1 0 { 0 0 yqjdm ksrky exch qnfpt mul dup /blsmk exch dup mul ksrky dup mul add sqrt ksrky div def [ .1 oxlrn blsmk mul 1.9 oxlrn blsmk mul ] 0 setdash vrszi  
stroke } for 0 1 hjahz { 0 0 yqjdm ksrky exch qnfpt mul dup /blsmk exch dup mul ksrky dup mul add sqrt ksrky div def [ ] 0 setdash vrszi stroke } for kxtcq  
ofmtt /uwcok 1 def SetCol iuflg 0 0 yqjdm 90 rotate hjahz neg 1 0 { 0 0 yqjdm ksrky exch qnfpt mul dup /blsmk exch dup mul ksrky dup mul add sqrt ksrky div def  
[ .1 oxlrn blsmk mul 1.9 oxlrn blsmk mul ] 0 setdash vrszi stroke } for 0 1 hjahz { 0 0 yqjdm ksrky exch qnfpt mul dup /blsmk exch dup mul ksrky dup mul add  
sqrt ksrky div def [ ] 0 setdash vrszi stroke } for kxtcq /Helvetica .028 vijkv selectfont fszgn czrao ne { (Xi) nkcul 2 div neg ksrky 1.015 mul yqjdm (X) ovoln  
ofmtt (.) nkcul .27 mul kmmfi currentpoint exch (W) nkcul .04 mul add exch (W) nkcul .4 mul add yqjdm (,) nkcul 0 vrszi currentpoint stroke yqjdm 0 (M) nkcul  
-.13 mul vrszi (M) nkcul +.45 mul (M) nkcul .13 mul vrszi (M) nkcul -.45 mul (M) nkcul .13 mul vrszi hjlyd fill kxtcq (N) nkcul 0 mksek ksrky 1.015 mul -.013  
vijkv yqjdm (Y) ovoln ofmtt (.) nkcul .27 mul kmmfi currentpoint exch (J) nkcul .5 mul add exch yqjdm 0 (,) nkcul vrszi currentpoint stroke yqjdm (M) nkcul -.13  
mul 0 vrszi (M) nkcul .13 mul (M) nkcul +.45 mul vrszi (M) nkcul .13 mul (M) nkcul -.45 mul vrszi hjlyd fill kxtcq (J) nkcul 0 mksek } if ofmtt /yzpnp { -0.0152  
vijkv } zwbyj /cehad { ksrky exch hkoih div div } zwbyj /kooub 1.05 ksrky mul def /kbipn { ltebg hkoih gt { kooub ltebg cehad sub (0.) nkcul gt { .00056 vijkv  
kmmfi ofmtt /uwcok 0 def (K) iuflg fjkhn ltebg cehad tppgn neg yqjdm 0 tppgn 2 mul vrszi stroke kxtcq ofmtt /uwcok 0 def (K) iuflg fjkhn tppgn neg ltebg cehad  
translate 0 0 yqjdm 90 rotate 0 tppgn -2 mul vrszi stroke kxtcq /pixuo { ltebg cehad .0011 mul lxhrx mul 245 hkoih div mul uzges div (0) nkcul add neg } zwbyj  
ofmtt ltebg cehad (.) nkcul add pixuo translate 90 rotate 0 0 ltebg ertpu uhgmg kxtcq ofmtt pixuo ltebg cehad (..) nkcul .8 mul sub ltebg ertpu uhgmg kxtcq  
/kooub ltebg cehad def } if } if } zwbyj 0 0 dnzox /ltebg 10 def kbipn /ltebg 12.5 def kbipn /ltebg 15 def kbipn /ltebg 17.5 def kbipn /ltebg 20 def kbipn  
/ltebg 25 def kbipn /ltebg 30 def kbipn /ltebg 40 def kbipn /ltebg 50 def kbipn /ltebg 65 def kbipn /ltebg 85 def kbipn /ltebg 100 def kbipn /ltebg 110 def  
kbipn /ltebg 120 def kbipn /ltebg 133 def kbipn /ltebg 150 def kbipn /ltebg 175 def kbipn /ltebg 200 def kbipn /ltebg 250 def kbipn /ltebg 300 def kbipn /ltebg  
350 def kbipn /ltebg 400 def kbipn /ltebg 500 def kbipn /ltebg 600 def kbipn /ltebg 700 def kbipn /ltebg 800 def kbipn /ltebg 1000 def kbipn /ltebg 1200 def  
kbipn /ltebg 1400 def kbipn /ltebg 1600 def kbipn /ltebg 1800 def kbipn /ltebg 2100 def kbipn /ltebg 2400 def kbipn kxtcq ofmtt .13 vijkv .75 vijkv yqjdm  
/Helvetica .037 vijkv selectfont (X-Y Addressability Indicator and Gradient) ovoln /Helvetica .024 vijkv selectfont .81 vijkv .71 vijkv (Ver. 1.3) uhgmg /tyiru  
.78 vijkv .13 vijkv sub def kxtcq ofmtt /Helvetica .029 vijkv selectfont /aumfp { tyiru bkwuj length 2 lt { (Output device:  ) qoeyr pop snphh tpvaf } {  
(Output device:  ) qoeyr pop snphh tpvaf (   #) tpvaf bkwuj nrovc } ifelse div } def aumfp 1 gt { /aumfp 1 def } if /xyqar { tyiru  
(Addressability reported by RIP:  ) qoeyr pop czrao fszgn ne { (spix= ) tpvaf czrao nrovc (  spiy= ) tpvaf fszgn nrovc } { /Helvetica .040 vijkv selectfont  
xqqlc tpvaf /Helvetica .029 vijkv selectfont ( spi,  ) tpvaf bgzbk nrovc ( u) tpvaf (/spot) tpvaf } ifelse div } def xyqar 1 gt { /xyqar 1 def } if aumfp xyqar  
gt { /zaybh xyqar def } { /zaybh aumfp def } ifelse /Helvetica .029 vijkv zaybh mul selectfont ofmtt -.128 vijkv -.125 vijkv translate 0 0 yqjdm 90 rotate bkwuj  
length 2 lt { (Output device:  ) ovoln snphh ovoln } { (Output device:  ) ovoln snphh ovoln (   #) ovoln bkwuj ovoln } ifelse kxtcq .13 vijkv .66 vijkv yqjdm  
-.145 vijkv -.16 vijkv yqjdm (Addressability reported by RIP:  ) ovoln czrao fszgn ne { (spix= ) ovoln czrao jhhdn (  spiy= ) ovoln fszgn jhhdn } { /Helvetica  
.040 vijkv zaybh mul selectfont xqqlc ovoln /Helvetica .029 vijkv zaybh mul selectfont ( spi,  ) ovoln bgzbk jhhdn ofmtt [ .9 0 -10 sin -.95 0 0 ] concat 0 (h)  
nkcul -.95 mul mksek (h) ovoln kxtcq (  ) ovoln (/spot) ovoln } ifelse kxtcq ofmtt /Helvetica findfont [ 0.023 vijkv 0 0 0.023 vijkv 0 0 ] skaee /pvbbo tyiru  
(Licensed user: ) nkcul un tpvaf div def pvbbo 1 gt { /pvbbo 1 def } if /Helvetica findfont [ 0.023 vijkv pvbbo mul 0 0 0.023 vijkv 0 0 ] skaee ofmtt -.04  
vijkv dup translate -45 rotate 0 0 (spi) rgcai kxtcq .82 vijkv -.16 vijkv translate 90 rotate 0 0 yqjdm (Licensed user: ) ovoln un ovoln llllll 0 eq { .13 vijkv  
.53 vijkv yqjdm } if kxtcq 1 1 eq { ofmtt .78 vijkv 0.71 vijkv sub .062 vijkv translate 0 0 yqjdm /uwcok 1 def (K) iuflg .33 vijkv dup translate 0 0 transform  
round .5 add exch .5 add exch itransform translate 0 0 moveto /Helvetica findfont 6 scalefont setfont .3 kmmfi /ikntl .28 vijkv def /ibkot 360 257 div def  
/pquku ikntl 2 mul 3.1416 mul 255 div def /ssteu pquku 2 div def ofmtt ibkot 2 div rotate 255 -1 0 { /uwcok exch 1 add 1 256 div mul cfsne def SetCol iuflg 0 0  
yqjdm ssteu ikntl fzdai pquku neg ikntl fzdai hjlyd fill ibkot rotate } for kxtcq ofmtt 36 36 360 { -36 rotate 0 ikntl yqjdm 0 3 vrszi stroke ofmtt 1.5 rotate  
3.6 div round cvi 0 ikntl 4 add 3 -1 roll ptyio (%) ovoln kxtcq } for kxtcq ofmtt -18 rotate 10 { 0 ikntl 1 add yqjdm 0 2 vrszi stroke -36 rotate } oxnkw kxtcq  
kxtcq } if kxtcq } bind def /bgyvf { ofmtt /egygg 1 def .8 wbxgb ayfxl ojdtf mul add ojdtf .5 mul add bxmrb ematv mul ematv .5 mul add translate 0 0 yqjdm ojdtf  
ematv lt { ojdtf 86 mm .66 mul div ematv 86 mm div lt { ojdtf 86 mm .66 mul div dup scale 90 rotate } { ematv 86 mm div dup scale 90 rotate } ifelse } { ojdtf  
86 mm div ematv 86 mm .66 mul div lt { ojdtf 86 mm div dup scale } { ematv 86 mm .66 mul div dup scale } ifelse } ifelse 72 72 matrix defaultmatrix dtransform  
/fszgn exch abs cvi def /czrao exch abs cvi def czrao cvi fszgn cvi lt { /ccuhb czrao def /hjhyz 0 def /kheeq 2 def } { /ccuhb fszgn def /hjhyz 1 def /kheeq 3  
def } ifelse /sruti 72 ccuhb matrix currentmatrix hjhyz get abs dup mul matrix currentmatrix kheeq get abs dup mul add sqrt div div def SetDPI 0 ne { /ccuhb  
SetDPI def } if /xqqlc ccuhb 15 string cvs def /osxva 72 ccuhb div sruti div def /oxlrn { osxva mul } zwbyj /nmjkh { osxva div round cvi osxva mul } zwbyj  
/aiscc 86 mm def aiscc -2 div aiscc .66 mul -2 div translate 0 0 yqjdm /wmexj where { pop true wmexj } if /vsxfj 0 def /ojfpq 85 def /dbqvq .35 def /lemzu 1 def  
SetCol (C) eq { /jmora { .2 0 0 0 } def } if SetCol (M) eq { /jmora { 0 .2 0 0 } def } if SetCol (Y) eq { /jmora { 0 0 .2 0 } def } if SetCol (K) eq { /jmora {  
0 0 0 .2 } def } if /qxidl { aiscc mul } zwbyj /ujktl { .46 qxidl } zwbyj /snehc { ujktl 8.5 div } zwbyj /zhqhw { 15 25.4 mm ojfpq div ujktl .95 mul atan div  
sruti mul cvi } zwbyj /iuehb { 15 zhqhw div } zwbyj /mlpai { 5 iuehb div cvi } zwbyj /ditqz { mlpai iuehb mul } zwbyj /vopex { 180 ditqz add ditqz add } zwbyj  
/ippts { 1 iuehb dbqvq mul cqkyc div osxva mul } zwbyj /pquku { ujktl iuehb dbqvq mul sin mul osxva sub } zwbyj /cehad { 25.4 mm exch div iuehb cqkyc div sruti  
div } zwbyj .5 qxidl .094 qxidl translate 0 0 dnzox 0 0 translate ofmtt /uwcok .2 cfsne def SetCol iuflg -.5 qxidl 1 add -.094 qxidl 1 add dnzox aiscc 2 sub 0  
vrszi 0 aiscc .66 mul 2 sub vrszi aiscc neg 2 add 0 vrszi closepath fill kxtcq /uwcok 1 def SetCol iuflg vsxfj 1 eq { /uwcok 1 def (K) iuflg } if 2 setflat 0  
.031 qxidl translate 0 0 dnzox 0 0 translate fjkhn ofmtt ditqz neg rotate 0 0 snehc 0 vopex arc 0 0 ujktl vopex 0 arcn hjlyd clip fjkhn 90 ujktl .5 pquku mul  
atan sub -1 mul rotate mlpai { 0 0 dnzox ujktl 0 vrszi 0 pquku vrszi ippts 0 fzdai hjlyd iuehb rotate fill 0 0 dnzox } oxnkw 0 0 dnzox ujktl pquku -1 iuehb .6  
mul ojfpq sqrt mul div mul fzdai ujktl pquku 1 1 iuehb .6 mul ojfpq sqrt mul div add mul fzdai hjlyd fill 0 0 dnzox 12 { zhqhw { 0 0 dnzox ujktl 0 vrszi 0 pquku  
vrszi ippts 0 fzdai hjlyd iuehb rotate currentpoint fill dnzox } oxnkw 0 0 dnzox ujktl pquku -1 iuehb .6 mul ojfpq sqrt mul div mul fzdai ujktl pquku 1 1 iuehb  
.6 mul ojfpq sqrt mul div add mul fzdai hjlyd fill 0 0 dnzox } oxnkw mlpai 1 add { 0 0 dnzox ujktl 0 vrszi 0 pquku vrszi ippts 0 fzdai hjlyd iuehb rotate fill 0  
0 dnzox } oxnkw kxtcq /Helvetica .027 qxidl selectfont ofmtt /yzpnp { -0.013 qxidl } zwbyj /rtgon 1.05 ujktl mul def /ohkjz (00) nkcul def /npmaj 1.05 ujktl mul  
def /drdfj (00) nkcul def /cqslk ujktl iuehb cqkyc mul ojfpq sqrt 5 div mul def /isfbx cqslk osxva add 2 div def /blttv isfbx def /kbipn { ujktl ltebg cehad gt  
snehc ltebg cehad lt and { rtgon ltebg cehad sub .9 mul ohkjz ltebg bcida nkcul add 2 div gt { lemzu 1 eq { /blttv blttv -1 mul def [ cqslk isfbx blttv add ] 0  
setdash } if .09 qxidl ltebg div kmmfi fjkhn 0 0 ltebg cehad -1 ditqz mul 180 ditqz add arc stroke /yzpnp yzpnp neg def /pixuo { -.040 qxidl yzpnp add } zwbyj  
-5 rotate ltebg cehad pixuo ltebg bcida ofmtt /uwcok 1 def (K) iuflg rgcai kxtcq 10 rotate -1 ltebg cehad mul pixuo ltebg bcida ofmtt /uwcok 1 def (K) iuflg  
rgcai kxtcq -5 rotate /ohkjz drdfj def /drdfj ltebg bcida nkcul def /rtgon npmaj def /npmaj ltebg cehad def } if } if } zwbyj 0 0 dnzox /ltebg 10 def kbipn  
/ltebg 12.5 def kbipn /ltebg 15 def kbipn /ltebg 17.5 def kbipn /ltebg 20 def kbipn /ltebg 25 def kbipn /ltebg 30 def kbipn /ltebg 35 def kbipn /ltebg 40 def  
kbipn /ltebg 50 def kbipn /ltebg 65 def kbipn /ltebg 85 def kbipn /ltebg 100 def kbipn /ltebg 120 def kbipn /ltebg 133 def kbipn /ltebg 150 def kbipn /ltebg 175  
def kbipn /ltebg 200 def kbipn /ltebg 250 def kbipn /ltebg 300 def kbipn /ltebg 400 def kbipn /ltebg 500 def kbipn kxtcq /uwcok 1 def (K) iuflg ofmtt /Helvetica  
.021 qxidl selectfont 0 -.08 qxidl (Lines / inch) rgcai /fmwvk snphh nkcul bkwuj length 1 gt { (   #) tpvaf bkwuj tpvaf } if ccuhb cvi bcida tpvaf  
(,   spi,     ) tpvaf (    2007 Franz Sigg) tpvaf def /zaybh .95 qxidl fmwvk div def zaybh 1 gt { /zaybh 1 def } if /Helvetica .021 qxidl zaybh mul selectfont  
fmwvk zaybh mul 2 div neg -.110 qxidl yqjdm kxtcq ofmtt /Helvetica findfont [ .035 qxidl 0 0 .025 qxidl 0 0 ] skaee (Screen Pattern Analyzer for Proofs       )  
nkcul 2 div neg .5 qxidl yqjdm /Helvetica findfont [ .035 qxidl 0 0 .025 qxidl 0 0 ] skaee (Screen Pattern Analyzer for Proofs) ovoln /Helvetica findfont [ .017  
qxidl 0 0 .015 qxidl 0 0 ] skaee (   Ver. 0.2) ovoln kxtcq /mjguo { ofmtt currentpoint exch (o) nkcul .15 mul add exch (o) nkcul .8 mul add translate 0 0 yqjdm  
.6 .5 scale (o) ovoln kxtcq } zwbyj -90 rotate ( 90.) nkcul -2 div ujktl 0.01 qxidl add yqjdm ( 90) ovoln mjguo 15 rotate ( 75.) nkcul -2 div ujktl 0.01 qxidl  
add yqjdm ( 75) ovoln mjguo 15 rotate ( 60.) nkcul -2 div ujktl 0.01 qxidl add yqjdm ( 60) ovoln mjguo 15 rotate ( 45.) nkcul -2 div ujktl 0.01 qxidl add yqjdm  
( 45) ovoln mjguo 15 rotate ( 30.) nkcul -2 div ujktl 0.01 qxidl add yqjdm ( 30) ovoln mjguo 15 rotate ( 15.) nkcul -2 div ujktl 0.01 qxidl add yqjdm ( 15)  
ovoln mjguo 15 rotate ( 0.) nkcul -2 div ujktl 0.01 qxidl add yqjdm ( 0) ovoln mjguo 15 rotate ( -15.) nkcul -2 div ujktl 0.01 qxidl add yqjdm (-15) ovoln mjguo  
15 rotate ( -30.) nkcul -2 div ujktl 0.01 qxidl add yqjdm (-30) ovoln mjguo 15 rotate ( -45.) nkcul -2 div ujktl 0.01 qxidl add yqjdm (-45) ovoln mjguo 15  
rotate ( -60.) nkcul -2 div ujktl 0.01 qxidl add yqjdm (-60) ovoln mjguo 15 rotate ( -75.) nkcul -2 div ujktl 0.01 qxidl add yqjdm (-75) ovoln mjguo 15 rotate  
( -90.) nkcul -2 div ujktl 0.01 qxidl add yqjdm (-90) ovoln mjguo kxtcq } zwbyj /nqcsg { ofmtt currentpoint translate 0 0 yqjdm rotate currentpoint transform  
/bhyiq exch def /jjiff exch def /lqgrp exch def zluic -2 div wpwvt -2 div translate 0 0 yqjdm currentpoint transform /pcbdg exch def /kphvx exch def /uwcok 1  
def (K) iuflg toeim kmmfi toeim 2 div dup yqjdm zluic toeim sub 0 vrszi 0 wpwvt toeim sub vrszi zluic toeim sub neg 0 vrszi hjlyd stroke usguw xwjzn 2 div sub  
wpwvt nwokv 2 mul sub 2 div translate 0 0 yqjdm /nkage pyniw 0 add array def /qzigw pyniw 0 add array def /dopps pyniw 0 add array def /wckvg pyniw 0 add array  
def ofmtt 0 1 pyniw 1 sub { /rkvlv exch def rkvlv .5 add sxdur .5 xvuum yqjdm currentpoint qzigw exch rkvlv exch put nkage exch rkvlv exch put rkvlv .5 add  
sxdur 1.5 xvuum yqjdm currentpoint wckvg exch rkvlv exch put dopps exch rkvlv exch put } for kxtcq /Helvetica findfont [ 9 0 0 7 0 0 ] makefont setfont ofmtt 0  
nwokv 2 mul vrszi usguw xwjzn 2 div sub -1 mul 0 vrszi 0 nwokv 2 mul neg vrszi hjlyd /uwcok 1 def (K) iuflg fill /uwcok 0 def (K) iuflg ofmtt -.85 sxdur nwokv  
translate 0 0 yqjdm -90 rotate 0 0 lqgrp ptyio kxtcq NominalTVflag 0 ne { ofmtt -.5 sxdur .55 xvuum translate -90 rotate 0 0 (Lin) rgcai kxtcq } if ofmtt -.5  
sxdur 1.55 xvuum translate -90 rotate 0 0 (Nom) rgcai kxtcq kxtcq ofmtt 0 1 pyniw 1 sub { /rkvlv exch def /uwcok NominalTVArray rkvlv get 100 div def SetCol  
iuflg rkvlv pyniw 1 sub eq { rkvlv sxdur nwokv yqjdm ofmtt /uwcok NominalTVArray rkvlv get 100 div def SetCol iuflg usguw xwjzn 2 div sub 0 vrszi 0 nwokv vrszi  
usguw xwjzn 2 div sub neg 0 vrszi hjlyd fill kxtcq rkvlv sxdur 0 yqjdm ofmtt /uwcok NominalTVArray rkvlv get 100 div cfsne def SetCol iuflg usguw xwjzn 2 div  
sub 0 vrszi 0 nwokv vrszi usguw xwjzn 2 div sub neg 0 vrszi hjlyd fill kxtcq } { rkvlv sxdur nwokv yqjdm ofmtt /uwcok NominalTVArray rkvlv get 100 div def  
SetCol iuflg usguw 0 vrszi 0 nwokv vrszi usguw neg 0 vrszi hjlyd fill kxtcq rkvlv sxdur 0 yqjdm ofmtt /uwcok NominalTVArray rkvlv get 100 div cfsne def SetCol  
iuflg usguw 0 vrszi 0 nwokv vrszi usguw neg 0 vrszi hjlyd fill kxtcq } ifelse } for kxtcq ofmtt ybvfh 1 eq { 0 setlinecap xwjzn kmmfi /uwcok .5 def (K) iuflg 0  
0 yqjdm 0 nwokv 2 mul vrszi stroke 1 1 pyniw 0 sub { /ftxfz exch def NominalTVArray ftxfz 1 sub get NominalTVArray ftxfz 1 sub get add 2 div 50 gt { /uwcok 0  
def (K) iuflg } { /uwcok 1 def (K) iuflg } ifelse ftxfz sxdur 0 yqjdm ofmtt 0 nwokv 2 mul vrszi stroke kxtcq } for } if kxtcq ofmtt /Helvetica findfont [ 7 0 0  
7 0 0 ] makefont setfont /uwcok 1 def (K) iuflg 0.5 sxdur 2.07 xvuum yqjdm 0 1 pyniw 1 sub { ofmtt currentpoint NominalTVArray 4 -1 roll get ptyio kxtcq usguw 0  
mksek } for 0.5 sxdur -0.265 sxdur yqjdm 0 1 pyniw 1 sub { ofmtt currentpoint NominalTVArray 4 -1 roll get cfsne 10 mul round cvi 10 div ptyio kxtcq usguw 0  
mksek } for kxtcq kxtcq } zwbyj /zwnql { ofmtt /eqpwj { 72 div 25400 mul kksiq mul round cvi 2 mul 1000 exch div 1000 mul round cvi 1000 div } zwbyj /bnbjl BBX  
.35277778 mul def /hzaqp BBY .35277778 mul def (Target Name and Version) print (\011Contrast-Resolution Test Target  ) print BlockRefToneValues length evfyb  
(x) print PX evfyb (x) print PY evfyb (  v3.5) = (Target Description \011) print BlockRefToneValues length evfyb ( TV levels  ) print PX evfyb  
( Contrast steps  ) print PY evfyb ( Resolution steps   Patch Size ) print ptch 35.27778 mul round cvi 100 div evfyb ( mm ) = idxnu 1 gt { kzsmv { () =  
(Corners Paper to Target \050mm\051\011X even pages\011Y even pages\011X odd pages\011Y odd pages) = (   UL corner \011) print ricqo 10 mul round cvi 10 div  
evfyb (\011) print pvyfd bbvza add hzaqp sub 10 mul round cvi 10 div evfyb (\011) print sviwu 10 mul round cvi 10 div evfyb (\011) print jpjnm bbvza add hzaqp  
sub 10 mul round cvi 10 div evfyb (\011) print () = (   UR corner \011) print ricqo vdulo add bnbjl sub 10 mul round cvi 10 div evfyb (\011) print pvyfd bbvza  
add hzaqp sub 10 mul round cvi 10 div evfyb (\011) print sviwu vdulo add bnbjl sub 10 mul round cvi 10 div evfyb (\011) print jpjnm bbvza add hzaqp sub 10 mul  
round cvi 10 div evfyb (\011) print () = (   LL corner \011) print ricqo 10 mul round cvi 10 div evfyb (\011) print pvyfd 10 mul round cvi 10 div evfyb (\011)  
print sviwu 10 mul round cvi 10 div evfyb (\011) print jpjnm 10 mul round cvi 10 div evfyb (\011) print () = (   LR corner \011) print ricqo vdulo add bnbjl sub  
10 mul round cvi 10 div evfyb (\011) print pvyfd 10 mul round cvi 10 div evfyb (\011) print sviwu vdulo add bnbjl sub 10 mul round cvi 10 div evfyb (\011) print  
jpjnm 10 mul round cvi 10 div evfyb (\011) print () = } { () = (Corners Paper to Target \050mm\051\011X\011Y) = (   UL corner \011) print sviwu 10 mul round cvi  
10 div evfyb (\011) print jpjnm bbvza add hzaqp sub 10 mul round cvi 10 div evfyb () = (   UR corner \011) print sviwu vdulo add bnbjl sub 10 mul round cvi 10  
div evfyb (\011) print jpjnm bbvza add hzaqp sub 10 mul round cvi 10 div evfyb () = (   LL corner \011) print sviwu 10 mul round cvi 10 div evfyb (\011) print  
jpjnm 10 mul round cvi 10 div evfyb () = (   LR corner \011) print sviwu vdulo add bnbjl sub 10 mul round cvi 10 div evfyb (\011) print jpjnm 10 mul round cvi  
10 div evfyb () = } ifelse } { () = (Corners Paper to Target \050mm\051\011X\011Y) = (   UL corner \011) print puigw 10 mul round cvi 10 div evfyb (\011) print  
geege bbvza add hzaqp sub 10 mul round cvi 10 div evfyb () = (   UR corner \011) print puigw vdulo add bnbjl sub 10 mul round cvi 10 div evfyb (\011) print  
geege bbvza add hzaqp sub 10 mul round cvi 10 div evfyb () = (   LL corner \011) print puigw 10 mul round cvi 10 div evfyb (\011) print geege 10 mul round cvi  
10 div evfyb () = (   LR corner \011) print puigw vdulo add bnbjl sub 10 mul round cvi 10 div evfyb (\011) print geege 10 mul round cvi 10 div evfyb () = }  
ifelse () = (Target Origin \011UL) = () = (\011X\011Y) = (Target Size frame \050in\051\011) print fuxcx .072 div round cvi 1000 div evfyb (\011) print qxtin  
.072 div round cvi 1000 div evfyb () = (Target Size frame \050mm\051\011) print fuxcx 35.27778 mul round cvi 100 div evfyb (\011) print qxtin 35.27778 mul round  
cvi 100 div evfyb () = (Block Size tight frame \050mm\051\011) print PX bxmky gobvm add 35.27778 mul round cvi 100 div evfyb (\011) print PY qexjv gobvm add  
35.27778 mul round cvi 100 div evfyb () = () = (Number of Pages) print (\011) print idxnu evfyb () = (Number of Blocks per page) print (\011) print pizjh evfyb  
() = (Number of TV Blocks) print (\011) print BlockRefToneValues length evfyb () = (Addressability Indicator Block) print (\011) print  
AddressabilityIndicatorFlag 1 eq { (YES) } { (NO) } ifelse evfyb () = (Screen Pattern Indicator Block) print (\011) print ScreenPatternIndicatorFlag 1 eq {  
(YES) } { (NO) } ifelse evfyb () = (FullCsteps \011) print FullCsteps 1 eq { (YES) } { (NO) } ifelse evfyb () = (Patch Size \050mm\051) print (\011) print  
kuupj 352.7778 mul round cvi 1000 div evfyb () = (Margin between patches \050mm\051) print (\011) print gobvm 352.7778 mul round cvi 1000 div evfyb () =  
(Addressability \050spi\051) print (\011) print xqqlc evfyb () = (Color) print (\011) print SetCol print () = (SpotCorrection) print (\011) print  
SpotCorrection 1 eq { (YES) print } { (NO) print } ifelse () = (Output Device) print (\011) print snphh print () = (Licensed User) print (\011) print un print  
(  ) print lyomz evfyb () = () = (\011X\011Y) = (Paper Size \050in\051\011) print BBX .72 div round cvi 100 div evfyb (\011) print BBY .72 div round cvi 100  
div evfyb BBX 612 eq BBY 792 eq and { (\011Letter) print } if BBX 612 eq BBY 1008 eq and { (\011Legal) print } if BBX 792 eq BBY 1224 eq and { (\011Tabloid)  
print } if BBX 864 eq BBY 1296 eq and { (\011Tabloid+) print } if () = (Paper Size \050mm\051\011) print BBX .3527778 mul round cvi evfyb (\011) print BBY  
.3527778 mul round cvi evfyb BBX 595 eq BBY 841 eq and { (\011A4) print } if BBX 841 eq BBY 1190 eq and { (\011A3) print } if () = () =  
(Number of Resolution Steps) print (\011) print PY evfyb (\011\050Resolution steps are the same for all Tone Value Blocks\051) = (   RStep Count\011) print  
/nasiz endu pwcfq mul def 1 1 PY { evfyb (\011) print } for () = (   Resolution \050lp/mm\051) print (\011) print 1 1 PY { pop /nasiz nasiz pwcfq div def nasiz  
eqpwj evfyb (\011) print } for () = () = (Number of Contrast Steps) print (\011) print PX evfyb () =  
(Tone Value Blocks\011Metrics\011\011\011   UL Target to UL Fiducial\011\011 UL Target to UL Block Frame\011\011Contrast) print () = /hjijg 1 def  
(\011Tone \050TV%\051\011Block No.\011Page No.\011Xoffset \050mm\051\011Yoffset\050mm\051\011Xoffset \050mm\051\011Yoffset \050mm\051\011) print 1 1 PX {  
/psgoo exch def lhvhz psgoo 1 sub get evfyb (\011) print } for () = 1 1 idxnu { /zygvu exch def 1 1 pizjh { pop hjijg BlockRefToneValues length gt { exit } if  
(\011) print haixg hjijg 10 mul 2 add get evfyb (\011) print haixg hjijg 10 mul 1 add get evfyb (\011) print haixg hjijg 10 mul 0 add get evfyb (\011) print  
haixg hjijg 10 mul 3 add get evfyb (\011) print haixg hjijg 10 mul 4 add get evfyb (\011) print haixg hjijg 10 mul 5 add get evfyb (\011) print haixg hjijg 10  
mul 6 add get evfyb (\011) print /kqmmd haixg hjijg 10 mul 2 add get def FullCsteps .5 gt { /zeprc kqmmd 50 gt { 100 kqmmd sub 2 mul } { kqmmd 2 mul } ifelse  
def zeprc startc gt { /zeprc startc def } if } { /zeprc startc def } ifelse /qtulc 1 10 zeprc log endc log sub PX 1 sub div exp div def /zeprc zeprc def /mobkd  
zeprc qtulc div def 1 1 PX { pop /dizph mobkd qtulc mul def /mobkd dizph def dizph kqmmd 50 gt { 100 kqmmd sub } { kqmmd } ifelse 2 mul .01 add lt { dizph 100  
mul round 100 div evfyb (%) print } { (-) print } ifelse (\011) print } for () = /hjijg hjijg 1 add def } for } for () = () =  
(Spacing of Fiducial grid \050mm\051\011) print uadrg 72 div 25400 mul round cvi 1000 div evfyb () = () = (Fiducial marks from UL corner mark) =  
(   X direction \050mm\051\011) print 0 1 PX 0 sub { vffnq mul 72 div 25400 mul round cvi 1000 div evfyb (\011) print } for () =  
(   Y direction \050mm\051\011) print 0 1 PY 0 sub { lvoth mul 72 div 25400 mul round cvi 1000 div evfyb (\011) print } for () = () = () =  
(Number of Steps on StepWedge\011) print pyniw evfyb () = (Width of steps excluding sep. bar \050mm\051\011) print usguw xwjzn sub 352.77778 mul round cvi 1000  
div evfyb () = (Width of separation bar \050mm\051\011) print xwjzn 352.77778 mul round cvi 1000 div evfyb () = (Height of steps \050mm\051\011) print nwokv  
352.77778 mul round cvi 1000 div evfyb () = (Distance Zero to Solid patch \050mm\051\011) print usguw pyniw 1 sub mul 352.77778 mul round cvi 1000 div evfyb ()  
= (NominalTVflag \011) print NominalTVflag evfyb (\011\050When set to zero then Linearization is off, only nominal values are used.\051) =  
(NominalTVArray \050TV%\051 \011) print NominalTVArray { evfyb (\011) print } forall () = (LinearizedTvArray \050TV%\051 \011) print louof { 10 mul round cvi  
10 div evfyb (\011) print } forall () = () = (Step Wedge Coordinates from \011Positions\011) print (   Zero TV Nominal Step \011\011) print  
(   Zero TV Linearized Step\011\011) print (    Solid TV Nominal Step \011\011) print (    Solid TV Linearized Step\011) =  
(  UL corner of Target to center of \011PageNo \011X Nom \011Y Nom \011X Lin \011Y Lin\011X Nom \011Y Nom \011X Lin \011Y Lin) =  
(  Zero or Solid patch \050mm\051) print 1 1 idxnu { /zygvu exch def (\011 ) print bxzgo zygvu 10 mul 0 add get evfyb (\011 ) print bxzgo zygvu 10 mul 1 add  
get evfyb (\011 ) print bxzgo zygvu 10 mul 2 add get evfyb (\011 ) print bxzgo zygvu 10 mul 3 add get evfyb (\011 ) print bxzgo zygvu 10 mul 4 add get evfyb  
(\011 ) print bxzgo zygvu 10 mul 5 add get evfyb (\011 ) print bxzgo zygvu 10 mul 6 add get evfyb (\011 ) print bxzgo zygvu 10 mul 7 add get evfyb (\011 )  
print bxzgo zygvu 10 mul 8 add get evfyb () = } for kxtcq } zwbyj /kmbll { /uwcok 1 def (K) iuflg FullCsteps .5 gt { /zeprc erxhg 50 gt { 100 erxhg sub 2 mul }  
{ erxhg 2 mul } ifelse def zeprc startc gt { /zeprc startc def } if } { /zeprc startc def } ifelse /qtulc 1 10 zeprc log endc log sub PX 1 sub div exp div def  
/Helvetica findfont .32 bxmky scalefont setfont -.45 bxmky -.13 qexjv yqjdm (TV) ovoln -.45 bxmky -.42 qexjv yqjdm erxhg jhhdn (%) ovoln ofmtt /yheni exch def  
/nasiz endu pwcfq mul def /nkgbq PY 1 add array def 1 1 PY { /jowkp exch def /nasiz nasiz pwcfq div def PX bxmky .24 bxmky add gobvm add PY jowkp sub qexjv 0.45  
qexjv add gobvm 2 div add jowkp ptyio -.11 bxmky PY jowkp sub qexjv .45 qexjv add gobvm 2 div add nasiz 72 25400 div div kksiq mul round cvi 2 mul 100000 exch  
div dup 999 gt { 10 div round 10 div } { round 100 div } ifelse /jbcdd exch def nkgbq jowkp jbcdd put jbcdd 13 string cvs /tgdbs exch def ofmtt translate 0 0  
yqjdm 90 rotate 0 0 tgdbs rgcai kxtcq } for /vnuzn zeprc qtulc div def (Z) (Y) (X) (W) (V) (U) (T) (S) (R) (Q) (P) (O) (N) (M) (L) (K) (J) (I) (H) (G) (F) (E)  
(D) (C) (B) (A) /bqihr PX array def 26 -1 PX 1 add { -1 roll pop } for vffnq 2 div prpbv 2 div smefi currentpoint translate vffnq -2 div prpbv -2 div translate  
0 0 yqjdm ofmtt gobvm 2 div 0 smefi 0 1 PX 1 sub { /psgoo exch def /kjfwd exch def /vnuzn vnuzn qtulc mul def vnuzn 100 erxhg sub 2 mul .2 add le vnuzn erxhg 2  
mul .2 add le and { /kposd vnuzn 100 mul round cvi 100 div dup 100 eq { cvi } if 10 string cvs def bqihr psgoo kposd put ofmtt SetBackground 1 eq { psgoo bxmky  
0 smefi 0 PY qexjv gobvm add vrszi 1 bxmky gobvm .55 mul add 0 vrszi 0 PY qexjv gobvm add neg vrszi hjlyd /uwcok erxhg 100 div cfsne def yheni iuflg fill psgoo  
PX 1 sub eq { psgoo 1 add bxmky gobvm .5 mul add 0 smefi 0 PY qexjv gobvm add vrszi gobvm .5 mul 0 vrszi 0 PY qexjv gobvm add neg vrszi hjlyd /uwcok erxhg 100  
div cfsne def yheni iuflg fill } if } if kxtcq ofmtt /uwcok 1 def (K) iuflg psgoo bxmky prpbv .5 mul add gobvm add PY qexjv .12 qexjv add gobvm add kposd rgcai  
psgoo bxmky prpbv .5 mul add gobvm add -0.34 qexjv kjfwd rgcai kxtcq /uwcok erxhg 100 div vnuzn 200 div add cfsne def yheni iuflg ofmtt psgoo bxmky PY qexjv  
yqjdm /nasiz endu pwcfq mul def PY -1 1 { ofmtt /iauxh exch def /nasiz nasiz pwcfq div def nasiz SpotCorrection sub kmmfi psgoo .5 add bxmky gobvm 2 div add  
vffnq iauxh mul vffnq 2 div sub gobvm 2 div add smefi currentpoint translate 0 0 yqjdm currentpoint filtd 2 div sub exch prpbv 2 div sub exch yqjdm prpbv 0  
vrszi 0 filtd vrszi prpbv neg 0 vrszi hjlyd clip /uwcok erxhg 100 div vnuzn 200 div sub cfsne def yheni iuflg fill /uwcok erxhg 100 div vnuzn 200 div add cfsne  
def yheni iuflg 1 2 prpbv nasiz div cvi { /fyekj exch def ofmtt fjkhn 0 0 nasiz fyekj mul 0 360 arc hjlyd stroke kxtcq } for kxtcq } for kxtcq } if } for vffnq  
gobvm 2 div sub 0 mksek currentpoint smefi currentpoint translate 0 0 yqjdm kxtcq Frame 1 eq { /wmexj where { pop true wmexj } if /uwcok 1 def (K) iuflg .01  
pcyjj kmmfi 0 0 smefi PX bxmky gobvm add 0 vrszi 0 PY qexjv gobvm add vrszi PX bxmky gobvm add neg 0 vrszi hjlyd stroke -0.5 bxmky -0.5 bxmky smefi PX 1 add  
bxmky gobvm add 0 vrszi 0 PY 1 add qexjv gobvm add vrszi PX 1 add bxmky gobvm add neg 0 vrszi hjlyd stroke } if kxtcq ofmtt DotGrid 1 eq { 1 setlinecap [ 0  
vffnq ] 0 setdash ofmtt /uwcok 1 def (K) iuflg .07 pcyjj kmmfi /wmexj where { pop false wmexj } if gobvm 2 div vffnq PX 1 add bxmky { gobvm 2 div smefi 0 PY  
qexjv 1 add vrszi stroke } for kxtcq ofmtt /uwcok 0 def (K) iuflg .04 pcyjj kmmfi /wmexj where { pop false wmexj } if gobvm 2 div vffnq PX 1 add bxmky { gobvm 2  
div smefi 0 PY qexjv 1 add vrszi stroke } for kxtcq } if kxtcq } zwbyj /izpnd { ofmtt currentpoint translate 0 0 yqjdm fcqbq 1 gt { ofmtt fuxcx qxtin translate  
/xausg PX uadrg mul gobvm add def xausg ptch .5 mul add neg -1.09 ptch mul yqjdm /uwcok 1 def SetCol iuflg wpjkw /ymskg 256 string def /pomqt 256 string def 0 1  
255 { ymskg exch dup put } for /uwcok 1 def iuflg currentpoint translate 0 0 yqjdm /Helvetica findfont [ .29 bdill 0 0 .27 bdill 0 0 ] makefont setfont ofmtt  
currentpoint .7 bdill add (F") nkcul add mksek currentpoint translate 0 0 yqjdm -90 rotate kuupj .7 mul xausg scale wpjkw (C) eq { 1 256 8 [ 1 0 0 256 0 0 ] {  
ymskg } { pomqt } { pomqt } { pomqt } true 4 colorimage } if wpjkw (M) eq { 1 256 8 [ 1 0 0 256 0 0 ] { pomqt } { ymskg } { pomqt } { pomqt } true 4 colorimage  
} if wpjkw (Y) eq { 1 256 8 [ 1 0 0 256 0 0 ] { pomqt } { pomqt } { ymskg } { pomqt } true 4 colorimage } if wpjkw (K) eq { 1 256 8 [ 1 0 0 256 0 0 ] { pomqt  
} { pomqt } { pomqt } { ymskg } true 4 colorimage } if kxtcq .025 xausg 19 div mul kmmfi /uwcok 1 def (K) iuflg 0 10 90 { /becbo exch def xausg 100 div becbo  
mul 0 becbo ptyio xausg 100 div becbo mul (F) nkcul yqjdm 0 (") nkcul vrszi stroke } for xausg 0 100 ptyio xausg (F) nkcul yqjdm 0 (") nkcul vrszi stroke 5 10  
95 { /becbo exch def xausg 100 div becbo mul (F) nkcul yqjdm 0 (") nkcul vrszi stroke } for /Helvetica findfont [ .19 bdill 0 0 .16 bdill 0 0 ] makefont setfont  
2 2 8 { /becbo exch def xausg 100 div becbo mul 0 becbo ptyio xausg 100 div becbo mul (F.) nkcul yqjdm 0 (') nkcul vrszi stroke } for kxtcq } if ofmtt /uwcok 1  
def (K) iuflg .032 bdill kmmfi 0 0 yqjdm 0 qxtin vrszi fuxcx 0 vrszi 0 qxtin neg vrszi hjlyd 0 qxtin 1.15 bdill sub yqjdm fuxcx 0 vrszi stroke lvvbp {  
/Helvetica findfont 6 scalefont setfont fuxcx 8 add qxtin 2 div  
(At 100% magnification, the outside frame of the target is 123.3 mm wide and 123.3 mm high.  The size of the outer frame of each block is 99.9 x 99.9 mm .)  
nkcul 2 div sub translate 0 0 yqjdm 90 rotate (At 100% magnification, the outside frame of the target is ) ovoln fuxcx 35.27778 mul round cvi 100 div jhhdn  
( mm wide and ) ovoln qxtin 35.27778 mul round cvi 100 div jhhdn ( mm high.  The size of the outer frame of each block is ) ovoln ojdtf 35.27778 mul round cvi  
100 div jhhdn ofmtt /yfjxm (X) nkcul def /Helvetica findfont [ yfjxm 1.2 mul 0 0 yfjxm 0 0 ] makefont setfont currentpoint exch (W) nkcul .15 mul add exch (X)  
nkcul .25 mul add yqjdm (x) ovoln kxtcq (X) nkcul .95 mul 0 mksek ematv 35.27778 mul round cvi 100 div jhhdn ( mm.) ovoln } if kxtcq /uwcok 1 def (K) iuflg  
ofmtt .09 bdill qxtin .53 bdill sub translate 0 0 yqjdm /zaybh { /Helvetica findfont .52 bdill scalefont setfont (Contrast-Resolution Target ) nkcul /Helvetica  
findfont .34 bdill scalefont setfont BlockRefToneValues length synct PX synct (xx) tpvaf PY synct (  v3.5) tpvaf /Helvetica findfont .38 bdill scalefont setfont  
idxnu 1 gt { (    Pg. ) tpvaf xbpmw synct ( of ) tpvaf idxnu synct } if ojdtf .5 bdill add div } def zaybh 1 lt { /zaybh 1 def } if /Helvetica findfont .52  
bdill zaybh div scalefont setfont (Contrast-Resolution Target ) ovoln /Helvetica findfont .34 bdill zaybh div scalefont setfont BlockRefToneValues length jhhdn  
ofmtt /yfjxm (X) nkcul def /Helvetica findfont [ yfjxm 1.2 mul 0 0 yfjxm 0 0 ] makefont setfont currentpoint exch (W) nkcul .15 mul add exch (X) nkcul .25 mul  
add yqjdm (x) ovoln kxtcq (X) nkcul .95 mul 0 mksek PX jhhdn ofmtt /yfjxm (X) nkcul def /Helvetica findfont [ yfjxm 1.2 mul 0 0 yfjxm 0 0 ] makefont setfont  
currentpoint exch (W) nkcul .15 mul add exch (X) nkcul .25 mul add yqjdm (x) ovoln kxtcq (X) nkcul .95 mul 0 mksek PY jhhdn (  v3.5) ovoln /Helvetica findfont  
.38 bdill zaybh div scalefont setfont idxnu 1 gt { (    Pg. ) ovoln xbpmw jhhdn ( of ) ovoln idxnu jhhdn } if 0 .42 bdill neg yqjdm /Helvetica findfont .34  
bdill scalefont setfont /zaybh { (Output device ) nkcul snphh tpvaf (  Addressability ) tpvaf czrao fszgn ne { (spix= ) tpvaf czrao synct (   spiy= ) tpvaf  
fszgn synct } { xqqlc tpvaf ( spi, ) tpvaf bgzbk synct ( u) tpvaf (/spot) tpvaf } ifelse ojdtf .5 bdill add div } def zaybh 1 lt { /zaybh 1 def } if /Helvetica  
findfont .34 bdill zaybh div scalefont setfont (Output device ) ovoln snphh ovoln (  Addressability ) ovoln czrao fszgn ne { (spix= ) ovoln czrao jhhdn  
(   spiy= ) ovoln fszgn jhhdn } { xqqlc ovoln ( spi, ) ovoln bgzbk jhhdn ofmtt [ .9 0 -10 sin -.95 0 0 ] concat 0 (h) nkcul -.95 mul mksek (h) ovoln kxtcq  
(  ) ovoln (/spot) ovoln } ifelse kxtcq /Helvetica findfont .37 bdill scalefont setfont 0 1 fcqbq 1 sub { /gwbdz exch def vvzgr BlockRefToneValues length lt {  
gwbdz ojdtf mul ojdtf 2 div add .8 bdill add myfhp ematv mul .2 bdill add (% Contrast,  Log step increments) rgcai /vvzgr vvzgr myfhp add def } if } for myfhp 1  
sub -1 0 { /gwbdz exch def qzkbw BlockRefToneValues length lt { ofmtt .5 bdill ematv gwbdz mul ematv 2 div add translate 0 0 yqjdm 90 rotate 0 0  
(Resolution,  Line Pairs per Millimeter, Log steps) rgcai kxtcq /nasiz endu pwcfq mul def /qzkbw qzkbw fcqbq add def } if } for kxtcq } zwbyj /egpjn { ofmtt  
/Helvetica 11 selectfont BBX 600 lt pyniw 19 gt and { BBX hknar 5.5 mm sub sub zsxdd 6 mm sub translate 0 0 yqjdm 90 rotate } { BBX hknar 4 mm sub sub zsxdd  
translate 0 0 yqjdm 90 rotate } ifelse ofmtt (Company:) ovoln kxtcq ofmtt BBY .22 mul 0 mksek (Press:) ovoln kxtcq ofmtt BBY .44 mul 0 mksek (Paper:) ovoln  
kxtcq ofmtt BBY .67 mul 0 mksek (Ink:) ovoln kxtcq ofmtt BBY .85 mul 0 mksek (Date:) ovoln kxtcq kxtcq } zwbyj /xoytk { ofmtt uwcok 1 def (K) iuflg -24 zluic 2  
div 10 add mksek currentpoint translate 0 0 yqjdm 90 rotate 0 0 yqjdm /Helvetica findfont 12 scalefont setfont /tolbb pygyc nkcul ( Linearized Tone Values)  
tpvaf def (.) nkcul -0.2 mul 0 mksek NominalTVflag 0 ne { pygyc ovoln ( Linearized Tone Values) ovoln } { (Nominal Tone Values) ovoln } ifelse 0 -15 yqjdm  
/Helvetica findfont 8 scalefont setfont /zaybh { (Only to be used by: ) nkcul un tpvaf (  ) tpvaf PDFcode synct ( ) tpvaf lyomz synct tolbb div } def zaybh 1 lt  
{ /zaybh 1 def } if /Helvetica findfont 8 zaybh div scalefont setfont (Only to be used by: ) ovoln un ovoln (  ) ovoln PDFcode ovoln ( ) ovoln lyomz ovoln 0  
-25 yqjdm LicensedLocation length 2 gt { /Helvetica findfont 8 zaybh div scalefont setfont /xyqar { (Only to be used at : ) nkcul LicensedLocation tpvaf tolbb  
div } def xyqar 1 lt { /xyqar 1 def } if ofmtt /Helvetica findfont 8 zaybh div xyqar div scalefont setfont (Only to be used at : ) ovoln LicensedLocation ovoln  
} if 0 -45 yqjdm /Helvetica findfont 8 scalefont setfont SpotCorrection 1 eq { (SpotCorrection is On) ovoln } { (SpotCorrection is Off) ovoln } ifelse 0 -55  
yqjdm /Helvetica findfont 6 scalefont setfont ofmtt ( ) nkcul .85 mul dup .72 mul mksek [ .75 0 0 .75 0 0 ] concat (c) ovoln (.) nkcul .28 mul kmmfi ( ) nkcul  
-.87 mul ( ) nkcul .95 mul mksek currentpoint translate fjkhn 0 0 (.) nkcul 1.8 mul 0 360 hjlyd arc stroke kxtcq (   ) ovoln ( Franz Sigg, 2019 ) ovoln 0 5  
mksek /Helvetica 10 selectfont (                   Pg. ) ovoln xbpmw jhhdn (  of ) ovoln idxnu jhhdn kxtcq } zwbyj /jkjqe { ofmtt uwcok 1 def (K) iuflg zluic -2  
div wpwvt -.67 mul mksek currentpoint translate 0 0 yqjdm /lezhb { zluic 0 /Helvetica 11 selectfont NominalTVflag 0 ne { pygyc tpvaf ( Linearized Tone Values)  
tpvaf } { (Nominal Tone Values) tpvaf } ifelse /Helvetica 8 selectfont (      Pg. ) tpvaf xbpmw nrovc (  of ) tpvaf idxnu nrovc (      Only to be used by: )  
tpvaf un tpvaf (  ) tpvaf PDFcode tpvaf ( ) tpvaf lyomz nrovc LicensedLocation length 2 gt { (      Only to be used at : ) tpvaf LicensedLocation tpvaf } if  
SpotCorrection 1 eq { (      SpotCorrection is On) tpvaf } { (      SpotCorrection is Off) tpvaf } ifelse /Helvetica findfont 6 scalefont setfont (      ) tpvaf  
(   Franz Sigg, 2019 ) tpvaf div } def lezhb 1 gt { /lezhb 1 def } if /Helvetica 11 lezhb mul selectfont NominalTVflag 0 ne { pygyc ovoln  
( Linearized Tone Values) ovoln } { (Nominal Tone Values) ovoln } ifelse /Helvetica 8 lezhb mul selectfont (      Pg. ) ovoln xbpmw jhhdn (  of ) ovoln idxnu  
jhhdn (      Only to be used by: ) ovoln un ovoln (  ) ovoln PDFcode ovoln ( ) ovoln lyomz ovoln LicensedLocation length 2 gt { (      Only to be used at : )  
ovoln LicensedLocation ovoln } if SpotCorrection 1 eq { (      SpotCorrection is On) ovoln } { (      SpotCorrection is Off) ovoln } ifelse /Helvetica findfont  
6 lezhb mul scalefont setfont (      ) ovoln ofmtt ( ) nkcul .85 mul dup .72 mul mksek [ .75 0 0 .75 0 0 ] concat (c) ovoln (.) nkcul .28 mul kmmfi ( ) nkcul  
-.87 mul ( ) nkcul .95 mul mksek currentpoint translate fjkhn 0 0 (.) nkcul 1.8 mul 0 360 hjlyd arc stroke kxtcq (   ) ovoln ( Franz Sigg, 2019 ) ovoln kxtcq }  
zwbyj PX 6 lt { /PX 6 def } if PY 6 lt { /PY 6 def } if PX 26 gt { /PX 26 def } if PY 26 gt { /PY 26 def } if /PX PX cvi def /PY PY cvi def SpotCorrection .5 lt  
{ /SpotCorrection 0 def } { /SpotCorrection 1 def } ifelse AddressabilityIndicatorFlag .5 lt { /AddressabilityIndicatorFlag 0 def } {  
/AddressabilityIndicatorFlag 1 def } ifelse ScreenPatternIndicatorFlag .5 lt { /ScreenPatternIndicatorFlag 0 def } { /ScreenPatternIndicatorFlag 1 def } ifelse  
/usguw 8.9 mm def /zhmxx 1.12359551 def /nwokv usguw zhmxx mul def /sxdur { usguw mul ll mul } def /xvuum { nwokv mul ll mul } def /toeim .03 sxdur def /xwjzn  
0.9 mm def /zluic pyniw 1 add sxdur xwjzn sub def /wpwvt nwokv 2 mul 19 add def /ybvfh 1 def /bxzgo 30 10 mul array def endc startc gt { endc startc /endc exch  
def /startc exch def } if endu startu lt { endu startu /endu exch def /startu exch def } if startc 100 gt { /startc 100 def } if /startu startu 72 25400 div mul  
kksiq div def /endu endu 72 25400 div mul kksiq div def /iffdp endu startu div log def /pwcfq 10 iffdp PY 1 sub div exp def /lhvhz [ (A) (B) (C) (D) (E) (F)  
(G) (H) (I) (J) (K) (L) (M) (N) (O) (P) (Q) (R) (S) (T) (U) (V) (W) (X) (Y) (Z) ] def /kuupj ptch ccuhb mul 72 div 2 div cvi 2 mul 1 add 72 mul ccuhb div def  
/prpbv kuupj def /bdill { kuupj mul ll mul } def /wbxgb { prpbv mul ll mul } def /uadrg ptch pratio mul ccuhb mul 72 div 2 div cvi 2 mul 1 add 72 mul ccuhb div  
def /vffnq uadrg def /pcyjj { prpbv mul ll mul } def /bxmky { vffnq mul ll mul } def /gobvm prpbv pratio 1 sub mul nmjkh def /ojdtf PX 1 add bxmky gobvm add def  
/filtd kuupj def /lvoth uadrg def /bqnrj { filtd mul ll mul } def /qexjv { lvoth mul ll mul } def /ematv PY 1 add qexjv gobvm add def /hknar 12 mm def /zcubz 8  
mm def /zrree 8 mm def /zsxdd 12 mm def /haixg 30 10 mul array def /svcvv BlockRefToneValues length ScreenPatternIndicatorFlag add AddressabilityIndicatorFlag  
add def /fcqbq BBX zcubz hknar add sub .8 wbxgb sub ojdtf div cvi def fcqbq NoOfBlocksInXdir gt { /fcqbq NoOfBlocksInXdir def } if fcqbq svcvv gt { /fcqbq svcvv  
def } if /myfhp BBY zsxdd zrree add sub .8 bqnrj sub 1.1 bqnrj sub ematv div cvi def myfhp svcvv fcqbq div gt { /myfhp svcvv fcqbq div round cvi def } if /gicay  
BBX zcubz hknar add sub ojdtf fcqbq mul sub .8 bdill sub def /tlllw BBY zsxdd zrree add sub ematv myfhp mul sub .8 bdill sub 1.1 bqnrj sub def gicay wpwvt 5 add  
gt { /ksjkg true def } { /ksjkg false def } ifelse tlllw wpwvt 5 add gt { /fbuvi true def } { /fbuvi false def } ifelse ksjkg false eq fbuvi false eq and {  
/myfhp myfhp 1 sub def } if /gicay BBX zcubz hknar add sub ojdtf fcqbq mul sub .8 bdill sub def /tlllw BBY zsxdd zrree add sub ematv myfhp mul sub .8 bdill sub  
1.1 bqnrj sub def gicay wpwvt 5 add gt { /ksjkg true def } { /ksjkg false def } ifelse tlllw wpwvt 5 add gt { /fbuvi true def } { /fbuvi false def } ifelse  
ksjkg true eq fbuvi true eq and { /kzsmv true def } { /kzsmv false def } ifelse fcqbq myfhp mul 0 eq { () = (BlocksX = ) print fcqbq evfyb () = (BlocksY = )  
print myfhp evfyb () = () = (BLOCKS ARE TOO BIG TO FIT ON PAGE. Use larger paper, fewer patches or smaller patches) = () = } if /idxnu svcvv fcqbq myfhp mul div  
.45 add round cvi def /pizjh svcvv idxnu div .45 add round cvi def /fuxcx fcqbq ojdtf mul .8 wbxgb add def /qxtin myfhp ematv mul .8 bqnrj add 1.1 bqnrj add def  
/vdulo fuxcx .35277778 mul def /bbvza qxtin .35277778 mul def /zyzvk 0 def /egygg 0 def /qzkbw 0 def /vvzgr 0 def /rydjm 0 def /xevqf { ofmtt currentpoint  
translate 0 0 yqjdm myfhp 1 sub -1 0 { /bxmrb exch def 0 1 fcqbq 1 sub { /ayfxl exch def rydjm BlockRefToneValues length lt { ofmtt /ehtwg ayfxl ojdtf mul .5  
bxmky add .8 bdill add 35.27778 mul round cvi 100 div def /jwwkp bxmrb ematv mul .5 qexjv add 35.27778 mul round cvi 100 div def ayfxl ojdtf mul .5 bxmky add .8  
bdill add bxmrb ematv mul .5 qexjv add yqjdm currentpoint /eygai exch def /pjqts exch def /ebgfz PY qexjv gobvm add 35.27778 mul round cvi 100 div def haixg  
rydjm 1 add 10 mul 0 add xbpmw put haixg rydjm 1 add 10 mul 1 add rydjm 1 add put haixg rydjm 1 add 10 mul 2 add BlockRefToneValues rydjm get put haixg rydjm 1  
add 10 mul 3 add pjqts prpbv pratio 1 sub mul 2 div add 35.27778 mul round cvi 100 div put haixg rydjm 1 add 10 mul 4 add qxtin eygai ebgfz mm add prpbv pratio  
1 sub mul 2 div sub sub 35.27778 mul round cvi 100 div put haixg rydjm 1 add 10 mul 5 add pjqts 35.27778 mul round cvi 100 div put haixg rydjm 1 add 10 mul 6  
add qxtin eygai ebgfz mm add sub 35.27778 mul round cvi 100 div put currentpoint translate 0 0 yqjdm /erxhg BlockRefToneValues rydjm get cvi def SetCol kmbll  
/rydjm rydjm 1 add def kxtcq } { rydjm pizjh xbpmw mul lt AddressabilityIndicatorFlag 1 eq and zyzvk 0 eq and { lobof /rydjm rydjm 1 add def } { rydjm pizjh  
xbpmw mul lt ScreenPatternIndicatorFlag 1 eq and egygg 0 eq and { bgyvf /rydjm rydjm 1 add def } if } ifelse } ifelse } for } for kxtcq } zwbyj /rydjm 0 def  
kzsmv { /utkeo [ 0 0 0 -180 -180 0 0 -180 -180 0 0 -180 -180 0 0 -180 -180 0 0 -180 -180 0 0 -180 -180 0 0 -180 -180 0 0 -180 -180 ] def } { /utkeo [ 0 0 -180 0  
-180 0 -180 0 -180 0 -180 0 -180 0 -180 0 -180 0 -180 0 -180 0 -180 0 -180 0 -180 0 -180 0 -180 0 -180 ] def } ifelse /uwcok 1 def (K) iuflg /dhwrm {  
currentpoint /ogagy exch def /bwcsg exch def } zwbyj 1 1 idxnu { ofmtt /xbpmw exch def ofmtt /uwcok .0 def (K) iuflg 0 0 yqjdm BBX 0 vrszi 0 BBY vrszi BBX neg 0  
vrszi hjlyd ofmtt fill kxtcq .1 mm kmmfi stroke kxtcq kzsmv { xbpmw 2 div cvi 2 mul xbpmw eq { /ksjkg true def /fbuvi false def } { /ksjkg false def /fbuvi true  
def } ifelse } if /lvvbp true def /Helvetica findfont 6 scalefont setfont  
(At 100% magnification, the outside frame of the target is 123.3 mm wide and 123.3 mm high.  The size of the outer frame of each block is 99.9 x 99.9 mm .)  
nkcul qxtin gt { fbuvi true eq ksjkg false eq and { /lvvbp false def } if } { /lvvbp true def } ifelse egpjn /nulzd BBX fuxcx 12 add sub hknar sub zcubz sub 2  
div zcubz add ksjkg { wpwvt 2 div add } if def /rstmz BBY qxtin sub zsxdd sub zrree sub 2 div zsxdd add fbuvi { wpwvt 2 div add } if def /werhw nulzd .35277778  
mul def /tkcqc rstmz .35277778 mul def idxnu 1 gt { kzsmv { xbpmw 2 div cvi 2 mul xbpmw eq { /ricqo werhw def /pvyfd tkcqc def } { /sviwu werhw def /jpjnm tkcqc  
def } ifelse } { /sviwu werhw def /jpjnm tkcqc def } ifelse } { /puigw werhw def /geege tkcqc def } ifelse nulzd rstmz translate 0 0 dnzox currentpoint  
transform /nzkhr exch def /gsiby exch def izpnd xevqf kxtcq ofmtt gsiby nzkhr itransform /nzkhr exch def /gsiby exch def /hrzjj utkeo xbpmw get def fbuvi { BBX  
zcubz sub hknar sub 2 div zcubz add nzkhr wpwvt 2 div sub 9 sub yqjdm dhwrm xbpmw 0 hrzjj add dup /lsgwu exch def nqcsg jkjqe } if BBY 900 gt { ksjkg { gsiby  
wpwvt 2 div sub 9 sub nzkhr zluic 2 div add yqjdm dhwrm xbpmw 90 hrzjj add dup /lsgwu exch def nqcsg xoytk } if } { ksjkg { gsiby wpwvt 2 div sub 9 sub zsxdd 4  
mm add zluic 2 div add yqjdm dhwrm xbpmw 90 hrzjj add dup /lsgwu exch def nqcsg xoytk } if } ifelse kphvx pcbdg itransform /pcbdg exch def /kphvx exch def jjiff  
bhyiq itransform /bhyiq exch def /jjiff exch def /mdfgz nwokv 2 div neg def /aishi nwokv 2 div def /dimyb zluic 2 div usguw 1.5 mul xwjzn 2 div add sub usguw 2  
div div round cvi usguw 2 div mul def /tbqru zluic 2 div usguw .5 mul xwjzn 2 div add sub usguw 2 div div round cvi usguw 2 div mul neg def bxzgo xbpmw 10 mul 0  
add xbpmw put bxzgo xbpmw 10 mul 1 add bwcsg gsiby sub lsgwu 0 eq { dimyb sub } if lsgwu 90 eq { mdfgz add } if lsgwu -180 eq { dimyb add } if lsgwu -90 eq {  
mdfgz sub } if 3.5277778 mul round cvi 10 div put bxzgo xbpmw 10 mul 2 add nzkhr qxtin add ogagy sub lsgwu 0 eq { mdfgz add } if lsgwu 90 eq { dimyb add } if  
lsgwu -180 eq { mdfgz sub } if lsgwu -90 eq { dimyb sub } if 3.5277778 mul round cvi 10 div put bxzgo xbpmw 10 mul 3 add bwcsg gsiby sub lsgwu 0 eq { dimyb sub  
} if lsgwu 90 eq { aishi add } if lsgwu -180 eq { dimyb add } if lsgwu -90 eq { aishi sub } if 3.5277778 mul round cvi 10 div put bxzgo xbpmw 10 mul 4 add  
nzkhr qxtin add ogagy sub lsgwu 0 eq { aishi add } if lsgwu 90 eq { dimyb add } if lsgwu -180 eq { aishi sub } if lsgwu -90 eq { dimyb sub } if 3.5277778 mul  
round cvi 10 div put bxzgo xbpmw 10 mul 5 add bwcsg gsiby sub lsgwu 0 eq { tbqru sub } if lsgwu 90 eq { mdfgz add } if lsgwu -180 eq { tbqru add } if lsgwu -90  
eq { mdfgz sub } if 3.5277778 mul round cvi 10 div put bxzgo xbpmw 10 mul 6 add nzkhr qxtin add ogagy sub lsgwu 0 eq { mdfgz add } if lsgwu 90 eq { tbqru add }  
if lsgwu -180 eq { mdfgz sub } if lsgwu -90 eq { tbqru sub } if 3.5277778 mul round cvi 10 div put bxzgo xbpmw 10 mul 7 add bwcsg gsiby sub lsgwu 0 eq { tbqru  
sub } if lsgwu 90 eq { aishi add } if lsgwu -180 eq { tbqru add } if lsgwu -90 eq { aishi sub } if 3.5277778 mul round cvi 10 div put bxzgo xbpmw 10 mul 8 add  
nzkhr qxtin add ogagy sub lsgwu 0 eq { aishi add } if lsgwu 90 eq { tbqru add } if lsgwu -180 eq { aishi sub } if lsgwu -90 eq { tbqru sub } if 3.5277778 mul  
round cvi 10 div put kxtcq showpage } for zwnql 

%%Trailer
 end cleartomark restore 

%%EOF
